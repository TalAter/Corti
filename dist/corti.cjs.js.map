{"version":3,"file":"corti.cjs.js","sources":["../src/BasicEvent.js","../src/DOMException.js","../src/SpeechRecognitionEvent.js","../src/SpeechRecognitionResultList.js","../src/SpeechRecognitionResult.js","../src/SpeechRecognitionAlternative.js","../src/corti.js"],"sourcesContent":["class BasicEvent {\n  constructor(type) {\n    this.type = type;\n  }\n}\n\nexport default typeof globalThis.Event !== 'undefined' ? globalThis.Event : BasicEvent;\n","const CustomDOMException = (() => {\n  if (typeof globalThis.DOMException !== 'undefined') {\n    return globalThis.DOMException;\n  }\n  return class DOMException extends Error {\n    constructor(message, name) {\n      super(message);\n      this.name = name || 'DOMException';\n    }\n  };\n})();\n\nexport default CustomDOMException;\n","import BasicEvent from './BasicEvent';\n\nclass SpeechRecognitionEvent extends BasicEvent {\n  interpretation = null;\n\n  emma = null;\n\n  constructor(type, { resultIndex, results }) {\n    super(type);\n    this.resultIndex = resultIndex;\n    this.results = results;\n  }\n}\n\nexport default SpeechRecognitionEvent;\n","class SpeechRecognitionResultList {\n  constructor(results = []) {\n    results.forEach((result, index) => {\n      this[index] = result;\n    });\n    this.length = results.length;\n  }\n\n  item(index) {\n    if (arguments.length === 0) {\n      throw new TypeError(\n        \"Failed to execute 'item' on 'SpeechRecognitionResultList': 1 argument required, but only 0 present.\"\n      );\n    }\n    if (typeof index !== 'number' || Number.isNaN(index)) {\n      return this[0] || null;\n    }\n    return this[index] || null;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; i += 1) {\n      yield this[i];\n    }\n  }\n}\nexport default SpeechRecognitionResultList;\n","class SpeechRecognitionResult {\n  isFinal = true;\n\n  constructor(alternatives = []) {\n    alternatives.forEach((alternative, index) => {\n      this[index] = alternative;\n    });\n    this.length = alternatives.length;\n  }\n\n  item(index) {\n    if (arguments.length === 0) {\n      throw new TypeError(\n        \"Failed to execute 'item' on 'SpeechRecognitionResult': 1 argument required, but only 0 present.\"\n      );\n    }\n    if (typeof index !== 'number' || Number.isNaN(index)) {\n      return this[0] || null;\n    }\n    return this[index] || null;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; i += 1) {\n      yield this[i];\n    }\n  }\n}\nexport default SpeechRecognitionResult;\n","class SpeechRecognitionAlternative {\n  constructor(transcript, confidence = 1) {\n    this.transcript = transcript;\n    this.confidence = confidence;\n  }\n}\nexport default SpeechRecognitionAlternative;\n","//! Corti - A mock implementation of the browserâ€™s SpeechRecognition for automated testing\n//! version : 1.0.0-dev\n//! author  : Tal Ater @TalAter\n//! license : MIT\n//! https://github.com/TalAter/Corti\n\nimport BasicEvent from './BasicEvent';\nimport DOMException from './DOMException';\nimport SpeechRecognitionEvent from './SpeechRecognitionEvent';\nimport SpeechRecognitionResultList from './SpeechRecognitionResultList';\nimport SpeechRecognitionResult from './SpeechRecognitionResult';\nimport SpeechRecognitionAlternative from './SpeechRecognitionAlternative';\n\nclass SpeechRecognition {\n  /**\n   * The maximum number of SpeechRecognitionAlternatives provided per SpeechRecognitionResult\n   * @type {number}\n   */\n  #maxAlternatives = 1;\n\n  /**\n   * The language of the current SpeechRecognition\n   * @type {string}\n   */\n  #lang = '';\n\n  /**\n   * Controls whether continuous results are returned for each recognition, or only a single result\n   * @type {boolean}\n   */\n  #continuous = false;\n\n  /**\n   * Indicates whether interim results should be returned (true) or just the final result (false)\n   * @type {boolean}\n   */\n  #interimResults = false;\n\n  /**\n   * Indicates whether the recognition service has started\n   * @type {boolean}\n   * @private\n   */\n  #started = false;\n\n  /**\n   * Listeners for the events registered with addEventListener\n   * @type {Map<string, Function[]>}\n   * @private\n   * @todo Add support for other listeners defined in the spec https://dvcs.w3.org/hg/speech-api/raw-file/tip/webspeechapi#speechreco-events\n   */\n  #listeners = new Map([\n    ['start', []],\n    ['soundstart', []],\n    ['end', []],\n    ['result', []],\n  ]);\n\n  /**\n   * Listeners for the events registered with on* methods\n   * @type {Map<string, Function|null>}\n   * @private\n   * @todo Add support for other listeners defined in the spec https://dvcs.w3.org/hg/speech-api/raw-file/tip/webspeechapi#speechreco-events\n   */\n  #onListeners = new Map([\n    ['onstart', null],\n    ['onsoundstart', null],\n    ['onend', null],\n    ['onresult', null],\n  ]);\n\n  constructor() {\n    // Dynamically add getters and setters for on* properties\n    this.#onListeners.forEach((_, eventType) => {\n      Object.defineProperty(this, eventType, {\n        get: () => this.#onListeners.get(eventType),\n        set: value => {\n          if (typeof value === 'function') {\n            this.#onListeners.set(eventType, value);\n          }\n        },\n      });\n    });\n  }\n\n  get maxAlternatives() {\n    return this.#maxAlternatives;\n  }\n\n  set maxAlternatives(val) {\n    if (typeof val === 'number') {\n      this.#maxAlternatives = Math.floor(val);\n    } else {\n      this.#maxAlternatives = 0;\n    }\n  }\n\n  get lang() {\n    return this.#lang;\n  }\n\n  set lang(val) {\n    if (val === undefined) {\n      this.#lang = 'undefined';\n    } else {\n      this.#lang = val.toString();\n    }\n  }\n\n  get continuous() {\n    return this.#continuous;\n  }\n\n  set continuous(val) {\n    this.#continuous = Boolean(val);\n  }\n\n  get interimResults() {\n    return this.#interimResults;\n  }\n\n  set interimResults(val) {\n    this.#interimResults = Boolean(val);\n  }\n\n  /**\n   * Checks if the recognition has started.\n   * This is not part of the spec, but is used by mock object for testing.\n   * @returns {boolean}\n   */\n  isStarted() {\n    return this.#started;\n  }\n\n  /**\n   * Starts the speech recognition\n   * @throws {DOMException} If recognition has already started\n   */\n  start() {\n    if (this.#started) {\n      throw new DOMException(\"Failed to execute 'start' on 'SpeechRecognition': recognition has already started.\");\n    }\n\n    this.#started = true;\n\n    this.#emit('start');\n    this.#emit('soundstart');\n  }\n\n  /**\n   * Aborts the speech recognition\n   */\n  abort() {\n    if (!this.#started) {\n      return;\n    }\n    this.#started = false;\n    this.#emit('end');\n  }\n\n  /**\n   * Stops the speech recognition and attempts to return a SpeechRecognitionResult\n   * @todo Implement stop's behavior according to the spec. Unlike abort, stop will attempt to return a SpeechRecognitionResult using the audio captured so far.\n   */\n  stop() {\n    return this.abort();\n  }\n\n  /**\n   * Register an event listener for the given event type\n   * @param {string} type The type of event to listen for\n   * @param {Function} listener The callback function to be called when the event is fired\n   */\n  addEventListener(type, listener) {\n    if (this.#listeners.has(type)) {\n      this.#listeners.get(type).push(listener);\n    }\n  }\n\n  /* eslint class-methods-use-this: \"off\" */\n  /* eslint no-unused-vars: \"off\" */\n  /**\n   * Remove an event listener for the given event type\n   * @param {string} type The type of event to remove\n   * @param {Function} listener The callback function to be removed\n   * @todo Implement removeEventListener\n   */\n  removeEventListener(type, listener) {}\n\n  /**\n   * Simulate speech said and recognized (if SpeechRecognition is running)\n   * @param {string|string[]} alternatives The sentence or sentences to be said\n   */\n  say(alternatives) {\n    if (!this.#started) {\n      return;\n    }\n\n    const sentences = Array.isArray(alternatives) ? alternatives : [alternatives];\n\n    // Ensure the length of speechRecognitionAlternatives matches #maxAlternatives\n    if (sentences.length > this.#maxAlternatives) {\n      sentences.splice(this.#maxAlternatives);\n    } else {\n      const paddingNeeded = this.#maxAlternatives - sentences.length;\n      let previousPaddedSentence = sentences[0];\n      for (let i = 0; i < paddingNeeded; i += 1) {\n        // if i is even, add \"and so on\" to previousPaddedSentence else add \"and so forth\"\n        if (i % 2 === 0) {\n          previousPaddedSentence = `${previousPaddedSentence} and so on`;\n        } else {\n          previousPaddedSentence = `${previousPaddedSentence} and so forth`;\n        }\n        sentences.push(previousPaddedSentence);\n      }\n    }\n\n    const speechRecognitionAlternatives = sentences.map((sentence, index) => {\n      // Confidence starts at 0.95 and decreases by 10% but never under 0.01\n      const confidence = Math.max(0.95 * 0.9 ** index, 0.01);\n      return new SpeechRecognitionAlternative(sentence, confidence);\n    });\n\n    const SREvent = new SpeechRecognitionEvent('result', {\n      results: new SpeechRecognitionResultList([new SpeechRecognitionResult(speechRecognitionAlternatives)]),\n      resultIndex: 0,\n    });\n    this.#emit('result', SREvent);\n\n    if (!this.#continuous) {\n      this.abort();\n    }\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   * @param {string} eventType The type of event to emit\n   * @param {Object} eventObject The event object to emit\n   * @todo Corti will emit events in the order they were registered with addEventListener and then with the on* property. This is not the same as the Chrome implementation which will emit the listener registered with on* at the order it was registered.\n   */\n  #emit(eventType, eventObject) {\n    const eventToEmit = eventObject || new BasicEvent(eventType);\n\n    // Iterate over the listeners for the given event type\n    if (this.#listeners.has(eventType)) {\n      this.#listeners.get(eventType).forEach(listener => listener(eventToEmit));\n    }\n    const onListener = this.#onListeners.get(`on${eventType}`);\n    if (onListener) {\n      onListener(eventToEmit);\n    }\n  }\n}\n\nexport {\n  SpeechRecognition,\n  SpeechRecognitionEvent,\n  SpeechRecognitionResultList,\n  SpeechRecognitionResult,\n  SpeechRecognitionAlternative,\n};\n"],"names":["BasicEvent","DOMException"],"mappings":"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"}